import os
import math
from typing import List
from PIL import Image, ImageDraw, ImageFont

from loader import LocalAssetLoader
from extractor import SummaryDrawData, HarvestMapDrawData

import configs
DEFAULT_FONT_PATH = configs.DEFAULT_FONT_PATH
DEFAULT_BOLD_FONT_PATH = configs.DEFAULT_BOLD_FONT_PATH
DEFAULT_HEAVY_FONT_PATH = configs.DEFAULT_HEAVY_FONT_PATH

BG_PADDING = 20
BLACK = (0, 0, 0, 255); WHITE = (255, 255, 255, 255); RED = (255, 0, 0, 255)
WIDGET_BG_COLOR = (180, 180, 180, 255); WIDGET_BG_RADIUS = 10
DEFAULT_WATERMARK = "MapView & original code by MiddleRed, ported to python by NeuraXmy. Generated by mysekai_analyser."
MYSEKAI_HARVEST_MAP_IMAGE_SCALE = 0.8

SITE_ID_TO_NAME_MAP = {
    5: "grassland",
    7: "garden",
    6: "beach",
    8: "ruins"
}

try:
    if not os.path.exists(DEFAULT_FONT_PATH): raise IOError(f"Font file not found: {DEFAULT_FONT_PATH}")
    FONT_CACHE = {
        'regular_12': ImageFont.truetype(DEFAULT_FONT_PATH, 12),
        'heavy_24': ImageFont.truetype(DEFAULT_HEAVY_FONT_PATH, 24),
        'bold_15': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 15),
        'bold_14': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 14),
        'bold_30': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 30),
    }
except IOError as e:
    print(f"FATAL ERROR: {e}. Please ensure font files are in './resources/fonts'.")
    raise SystemExit("Font files are required.")

# --- Helper Functions ---
def add_watermark(image, text=DEFAULT_WATERMARK):
    draw = ImageDraw.Draw(image); font = FONT_CACHE['regular_12']
    try: text_len = font.getbbox(text)[2]
    except AttributeError: text_len = int(font.getlength(text))
    pos = (image.width - text_len - 10, image.height - 20)
    draw.text(pos, text, font=font, fill=(0,0,0,128)); return image

def draw_rounded_rect(image_draw, bounds, radius, fill):
    image_draw.rounded_rectangle(bounds, radius=radius, fill=fill)

# ======================================================================
#  资源统计图绘制逻辑
# ======================================================================
def draw_summary_image(data: SummaryDrawData, loader: LocalAssetLoader) -> Image.Image:
    canvas_w, canvas_h_est = 800, 2000
    bg_img = loader.get(f"mysekai/phenom_bg/{data.weather.current_phenomenon_id}.png") if hasattr(data, 'weather') else Image.new("RGBA", (1, 1))

    canvas = Image.new("RGBA", (canvas_w, canvas_h_est), (200, 220, 255, 255))
    if bg_img.width > 1:
        scale = max(canvas_w / bg_img.width, canvas_h_est / bg_img.height)
        resized = bg_img.resize((int(bg_img.width * scale), int(bg_img.height * scale)), Image.Resampling.LANCZOS)
        canvas.paste(resized.crop((0, 0, canvas_w, canvas_h_est)))

    draw = ImageDraw.Draw(canvas)
    y_cursor = BG_PADDING
    top_bar_h = 80
    title_text = "MySekai 资源分析"
    title_w = int(FONT_CACHE['heavy_24'].getlength(title_text))
    title_box_w, title_box_h = title_w + 32, 60
    draw_rounded_rect(draw, (BG_PADDING, y_cursor + top_bar_h - title_box_h, BG_PADDING + title_box_w, y_cursor + top_bar_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
    draw.text((BG_PADDING + 16, y_cursor + top_bar_h - title_box_h + 14), title_text, font=FONT_CACHE['heavy_24'], fill=BLACK)

    if hasattr(data, 'weather'):
        weather_box_w = 270
        weather_x_start = canvas_w - BG_PADDING - weather_box_w
        draw_rounded_rect(draw, (weather_x_start, y_cursor, weather_x_start + weather_box_w, y_cursor + top_bar_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
        weather_item_x = weather_x_start + 10
        for i, img in enumerate(data.weather.phenomena_images):
            if img.width > 1:
                img_sm = img.resize((50, 50))
                canvas.paste(img_sm, (weather_item_x, y_cursor + 15), img_sm)
                if i == data.weather.current_phenomenon_index:
                    draw.rectangle([weather_item_x - 2, y_cursor + 13, weather_item_x + 52, y_cursor + 67], outline=RED, width=2)
            weather_item_x += 60
    y_cursor += top_bar_h + 16

    panel_start_y = y_cursor
    panel_x_start, panel_x_end = BG_PADDING, canvas_w - BG_PADDING
    content_h = 16
    if hasattr(data, 'visited_characters') and data.visited_characters: content_h += 100 + 16
    if hasattr(data, 'site_summaries'):
        for site in data.site_summaries:
            num_rows = math.ceil(len(site.resources) / 5) if site.resources else 0
            site_box_h = num_rows * 45 + (num_rows - 1) * 5 + 32
            site_box_h = max(site_box_h, 85 + 32)
            content_h += site_box_h + 16
    draw_rounded_rect(draw, (panel_x_start, panel_start_y, panel_x_end, panel_start_y + content_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)

    panel_y_cursor = panel_start_y + 16

    if hasattr(data, 'visited_characters') and data.visited_characters:
        visited_box_h = 100
        draw_rounded_rect(draw, (panel_x_start + 16, panel_y_cursor, panel_x_end - 16, panel_y_cursor + visited_box_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
        if hasattr(data, 'gate_icon') and data.gate_icon.width > 1:
            gate_icon_resized = data.gate_icon.resize((64, 64))
            canvas.paste(gate_icon_resized, (panel_x_start + 32, panel_y_cursor + 18), gate_icon_resized)
        if hasattr(data, 'gate_level'):
            draw.text((panel_x_start + 32 + 32, panel_y_cursor + 100), f"Lv.{data.gate_level}", font=FONT_CACHE['bold_14'], fill=BLACK, anchor="ms")
        char_x = panel_x_start + 116
        for char in data.visited_characters:
            if hasattr(char, 'sd_image') and char.sd_image.width > 1:
                char_img_resized = char.sd_image.resize((80, 80))
                canvas.paste(char_img_resized, (char_x, panel_y_cursor + 10), char_img_resized)
                char_x += 85
        panel_y_cursor += visited_box_h + 16

    if hasattr(data, 'site_summaries'):
        for site in data.site_summaries:
            site_img = site.site_image
            site_img_resized = site_img.resize((int(site_img.width * 85 / site_img.height), 85)) if site_img.width > 1 else Image.new("RGBA", (150, 85))
            num_rows = math.ceil(len(site.resources) / 5) if site.resources else 0
            site_box_h = num_rows * 45 + (num_rows - 1) * 5 + 32
            site_box_h = max(site_box_h, 85 + 32)
            draw_rounded_rect(draw, (panel_x_start + 16, panel_y_cursor, panel_x_end - 16, panel_y_cursor + site_box_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
            if site_img_resized.width > 1: canvas.paste(site_img_resized, (panel_x_start + 32, panel_y_cursor + 16), site_img_resized)
            res_x_start = panel_x_start + 32 + site_img_resized.width + 16
            for i, res in enumerate(site.resources):
                col, row = i % 5, i // 5
                item_x, item_y = res_x_start + col * 120, panel_y_cursor + 16 + row * 45
                if res.image.width > 1:
                    res_img_resized = res.image.resize((40, 40))
                    canvas.paste(res_img_resized, (item_x, item_y), res_img_resized)
                color = (120, 120, 120)
                if hasattr(res, 'is_most_rare') and res.is_most_rare: color = (200, 50, 0)
                elif hasattr(res, 'is_rare') and res.is_rare: color = (50, 0, 200)
                draw.text((item_x + 45, item_y + 20), f"{res.quantity}", font=FONT_CACHE['bold_30'], fill=color, anchor="lm")
            panel_y_cursor += site_box_h + 16
    y_cursor = panel_y_cursor
    final_image = canvas.crop((0, 0, canvas_w, y_cursor + BG_PADDING - 16))
    return add_watermark(final_image)

# ======================================================================
#  地图绘制逻辑
# ======================================================================
def draw_harvest_map_image(data: HarvestMapDrawData, loader: LocalAssetLoader) -> Image.Image:
    canvas_img = data.map_bg_image.copy()
    draw = ImageDraw.Draw(canvas_img)
    if hasattr(data, 'harvest_points'):
        for point in data.harvest_points:
            if not hasattr(point, 'image') or point.image.width <= 1: continue
            img_w, img_h = point.image.size
            offset_x = int(point.x - img_w / 2)
            offset_y = int(point.y - img_h * 0.6)
            canvas_img.paste(point.image, (offset_x, offset_y), point.image)

    if hasattr(data, 'spawn_point'):
        cx, cz = data.spawn_point
        half_size = int(10 * MYSEKAI_HARVEST_MAP_IMAGE_SCALE)
        line_width = 3
        draw.line([(cx - half_size, cz - half_size), (cx + half_size, cz + half_size)], fill=RED, width=line_width)
        draw.line([(cx + half_size, cz - half_size), (cx - half_size, cz + half_size)], fill=RED, width=line_width)

    if hasattr(data, 'dropped_resources'):
        for res in data.dropped_resources:
            if not hasattr(res, 'image') or res.image.width <= 1: continue
            img = res.image.resize((res.size, res.size), Image.Resampling.LANCZOS)
            offset_x = 0
            offset_y = 30
            pos = (res.x + offset_x, res.z + offset_y)
            canvas_img.paste(img, pos, img)
            if hasattr(res, 'outline') and res.outline: draw.rectangle([pos, (pos[0] + res.size, pos[1] + res.size)], outline=res.outline[0], width=res.outline[1])
            if not hasattr(res, 'is_small_icon') or not res.is_small_icon:
                text = f"{res.quantity}"; scale = MYSEKAI_HARVEST_MAP_IMAGE_SCALE
                font_size = int(11*scale); font_path = DEFAULT_BOLD_FONT_PATH; color = (50,50,50,255)
                if res.quantity == 2: font_path,font_size,color = DEFAULT_HEAVY_FONT_PATH, int(13*scale), (200,20,0,255)
                elif res.quantity > 2: font_path,font_size,color = DEFAULT_HEAVY_FONT_PATH, int(13*scale), (200,20,200,255)
                font = ImageFont.truetype(font_path, font_size)
                draw.text((pos[0] - 1, pos[1] - 1), text, font=font, fill=color)
    return canvas_img

# ======================================================================
#  图片拼接逻辑
# ======================================================================
def combine_and_save_maps(map_data_list: List[HarvestMapDrawData], loader: LocalAssetLoader, filename: str):
    map_images = [draw_harvest_map_image(data, loader) for data in map_data_list]
    map_images = [img for img in map_images if img and img.width > 1]
    if not map_images: print("Warning: No valid maps were generated to combine."); return

    base_name, extension = os.path.splitext(filename)
    print("Saving individual maps...")
    for i, img in enumerate(map_images):
        site_id = map_data_list[i].site_id
        map_name = SITE_ID_TO_NAME_MAP.get(site_id, f"unknown_{site_id}")
        individual_filename = f"{base_name}_map_{map_name}{extension}"
        try:
            img.save(individual_filename)
            print(f"  - Saved: {individual_filename}")
        except Exception as e:
            print(f"  - FAILED to save {individual_filename}: {e}")

    cols = 2; rows = math.ceil(len(map_images) / cols); gap = 16
    col_widths = [0] * cols; row_heights = [0] * rows
    for i, img in enumerate(map_images):
        row, col = i // cols, i % cols
        if img.width > col_widths[col]: col_widths[col] = img.width
        if img.height > row_heights[row]: row_heights[row] = img.height
    total_w = sum(col_widths) + gap * (cols - 1) + BG_PADDING * 2
    total_h = sum(row_heights) + gap * (rows - 1) + BG_PADDING * 2
    final_canvas = Image.new("RGBA", (total_w, total_h), (200, 220, 255, 255))
    current_y = BG_PADDING
    for r in range(rows):
        current_x = BG_PADDING
        for c in range(cols):
            i = r * cols + c
            if i < len(map_images): final_canvas.paste(map_images[i], (current_x, current_y))
            current_x += col_widths[c] + gap
        current_y += row_heights[r] + gap
    final_image = add_watermark(final_canvas, text=DEFAULT_WATERMARK)
    final_image.save(filename)
    print(f"Combined map saved as: {filename}")