import os
import math
from typing import List, Tuple

from PIL import Image, ImageDraw, ImageFont

# 确保 extractor.py 和这个文件在同一个目录下，或者在 Python 的搜索路径中
# 这样我们才能导入数据类 (Data Class)
from extractor import SummaryDrawData, HarvestMapDrawData

import configs

# --- 常量和配置 ---
DEFAULT_FONT_PATH = configs.DEFAULT_FONT_PATH
DEFAULT_BOLD_FONT_PATH = configs.DEFAULT_BOLD_FONT_PATH
DEFAULT_HEAVY_FONT_PATH = configs.DEFAULT_HEAVY_FONT_PATH

BG_PADDING = 20
BLACK = (0, 0, 0, 255)
WHITE = (255, 255, 255, 255)
RED = (255, 0, 0, 255)
WIDGET_BG_COLOR = (180, 180, 180, 255)
WIDGET_BG_RADIUS = 10
DEFAULT_WATERMARK = "MapView & original code by MiddleRed, ported to python by NeuraXmy. Generated by mysekai_analyser."
MYSEKAI_HARVEST_MAP_IMAGE_SCALE = 1.0 # 与 extractor.py 中的 scale 保持一致

SITE_ID_TO_NAME_MAP = {
    5: "grassland",
    7: "garden",
    6: "beach",
    8: "ruins"
}

# --- 字体缓存 ---
try:
    if not os.path.exists(DEFAULT_FONT_PATH): raise IOError(f"Font file not found: {DEFAULT_FONT_PATH}")
    FONT_CACHE = {
        'regular_12': ImageFont.truetype(DEFAULT_FONT_PATH, 12),
        'heavy_24': ImageFont.truetype(DEFAULT_HEAVY_FONT_PATH, 24),
        'bold_15': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 15),
        'bold_14': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 14),
        'bold_30': ImageFont.truetype(DEFAULT_BOLD_FONT_PATH, 30),
    }
except IOError as e:
    print(f"FATAL ERROR: {e}. Please ensure font files are in './resources/fonts'.")
    raise SystemExit("Font files are required.")

# --- 辅助函数 ---
def add_watermark(image, text=DEFAULT_WATERMARK):
    draw = ImageDraw.Draw(image)
    font = FONT_CACHE['regular_12']
    try:
        # Pillow 10.0.0+
        bbox = font.getbbox(text)
        text_len = bbox[2] - bbox[0]
    except AttributeError:
        # Older versions
        text_len = int(font.getlength(text))
    pos = (image.width - text_len - 10, image.height - 20)
    draw.text(pos, text, font=font, fill=(0, 0, 0, 128))
    return image

def draw_rounded_rect(image_draw, bounds, radius, fill):
    image_draw.rounded_rectangle(bounds, radius=radius, fill=fill)


# ======================================================================
#  资源统计图绘制逻辑 (保持不变)
# ======================================================================
def draw_summary_image(data: SummaryDrawData, loader) -> Image.Image:
    canvas_w, canvas_h_est = 800, 2000
    bg_img = loader.get(f"mysekai/phenom_bg/{data.weather.current_phenomenon_id}.png") if hasattr(data, 'weather') else Image.new("RGBA", (1, 1))

    canvas = Image.new("RGBA", (canvas_w, canvas_h_est), (200, 220, 255, 255))
    if bg_img.width > 1:
        scale = max(canvas_w / bg_img.width, canvas_h_est / bg_img.height)
        resized = bg_img.resize((int(bg_img.width * scale), int(bg_img.height * scale)), Image.Resampling.LANCZOS)
        canvas.paste(resized.crop((0, 0, canvas_w, canvas_h_est)))

    draw = ImageDraw.Draw(canvas)
    y_cursor = BG_PADDING
    top_bar_h = 80
    title_text = "MySekai 资源分析"
    title_w = int(FONT_CACHE['heavy_24'].getlength(title_text))
    title_box_w, title_box_h = title_w + 32, 60
    draw_rounded_rect(draw, (BG_PADDING, y_cursor + top_bar_h - title_box_h, BG_PADDING + title_box_w, y_cursor + top_bar_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
    draw.text((BG_PADDING + 16, y_cursor + top_bar_h - title_box_h + 14), title_text, font=FONT_CACHE['heavy_24'], fill=BLACK)

    if hasattr(data, 'weather'):
        weather_box_w = 270
        weather_x_start = canvas_w - BG_PADDING - weather_box_w
        draw_rounded_rect(draw, (weather_x_start, y_cursor, weather_x_start + weather_box_w, y_cursor + top_bar_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
        weather_item_x = weather_x_start + 10
        for i, img in enumerate(data.weather.phenomena_images):
            if img.width > 1:
                img_sm = img.resize((50, 50))
                canvas.paste(img_sm, (weather_item_x, y_cursor + 15), img_sm)
                if i == data.weather.current_phenomenon_index:
                    draw.rectangle([weather_item_x - 2, y_cursor + 13, weather_item_x + 52, y_cursor + 67], outline=RED, width=2)
            weather_item_x += 60
    y_cursor += top_bar_h + 16

    panel_start_y = y_cursor
    panel_x_start, panel_x_end = BG_PADDING, canvas_w - BG_PADDING
    content_h = 16
    if hasattr(data, 'visited_characters') and data.visited_characters: content_h += 100 + 16
    if hasattr(data, 'site_summaries'):
        for site in data.site_summaries:
            num_rows = math.ceil(len(site.resources) / 5) if site.resources else 0
            site_box_h = num_rows * 45 + (num_rows - 1) * 5 + 32
            site_box_h = max(site_box_h, 85 + 32)
            content_h += site_box_h + 16
    draw_rounded_rect(draw, (panel_x_start, panel_start_y, panel_x_end, panel_start_y + content_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)

    panel_y_cursor = panel_start_y + 16

    if hasattr(data, 'visited_characters') and data.visited_characters:
        visited_box_h = 100
        draw_rounded_rect(draw, (panel_x_start + 16, panel_y_cursor, panel_x_end - 16, panel_y_cursor + visited_box_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
        if hasattr(data, 'gate_icon') and data.gate_icon.width > 1:
            gate_icon_resized = data.gate_icon.resize((64, 64))
            canvas.paste(gate_icon_resized, (panel_x_start + 32, panel_y_cursor + 18), gate_icon_resized)
        if hasattr(data, 'gate_level'):
            draw.text((panel_x_start + 32 + 32, panel_y_cursor + 100), f"Lv.{data.gate_level}", font=FONT_CACHE['bold_14'], fill=BLACK, anchor="ms")
        char_x = panel_x_start + 116
        for char in data.visited_characters:
            if hasattr(char, 'sd_image') and char.sd_image.width > 1:
                char_img_resized = char.sd_image.resize((100, 80))
                canvas.paste(char_img_resized, (char_x, panel_y_cursor + 10), char_img_resized)
                char_x += 85
        panel_y_cursor += visited_box_h + 16

    if hasattr(data, 'site_summaries'):
        for site in data.site_summaries:
            site_img = site.site_image
            site_img_resized = site_img.resize((int(site_img.width * 85 / site_img.height), 85)) if site_img.width > 1 else Image.new("RGBA", (150, 85))
            num_rows = math.ceil(len(site.resources) / 5) if site.resources else 0
            site_box_h = num_rows * 45 + (num_rows - 1) * 5 + 32
            site_box_h = max(site_box_h, 85 + 32)
            draw_rounded_rect(draw, (panel_x_start + 16, panel_y_cursor, panel_x_end - 16, panel_y_cursor + site_box_h), WIDGET_BG_RADIUS, WIDGET_BG_COLOR)
            if site_img_resized.width > 1: canvas.paste(site_img_resized, (panel_x_start + 32, panel_y_cursor + 16), site_img_resized)
            res_x_start = panel_x_start + 32 + site_img_resized.width + 16
            for i, res in enumerate(site.resources):
                col, row = i % 5, i // 5
                item_x, item_y = res_x_start + col * 120, panel_y_cursor + 16 + row * 45
                if res.image.width > 1:
                    res_img_resized = res.image.resize((40, 40))
                    canvas.paste(res_img_resized, (item_x, item_y), res_img_resized)
                color = (120, 120, 120)
                if hasattr(res, 'is_most_rare') and res.is_most_rare: color = (200, 50, 0)
                elif hasattr(res, 'is_rare') and res.is_rare: color = (50, 0, 200)
                draw.text((item_x + 45, item_y + 20), f"{res.quantity}", font=FONT_CACHE['bold_30'], fill=color, anchor="lm")
            panel_y_cursor += site_box_h + 16
    y_cursor = panel_y_cursor
    final_image = canvas.crop((0, 0, canvas_w, y_cursor + BG_PADDING - 16))
    return add_watermark(final_image)

# ======================================================================
#  地图绘制逻辑
# ======================================================================

def draw_harvest_map_image(data: HarvestMapDrawData, loader) -> Image.Image:
    """
    接收已经计算好所有左上角坐标的数据，直接在最终尺寸的画布上进行绘制。
    """
    canvas = Image.new("RGBA", (data.draw_width, data.draw_height))
    draw = ImageDraw.Draw(canvas, "RGBA")

    if data.map_bg_image.width > 1:
        canvas.paste(data.map_bg_image, (0, 0))

    # 绘制采集点
    if hasattr(data, 'harvest_points'):
        for point in data.harvest_points:
            if point.image.width > 1:
                canvas.paste(point.image, (point.x, point.y), point.image)

    # 绘制出生点
    if hasattr(data, 'spawn_point'):
        center_x, center_y = data.spawn_point
        spawn_size = int(20 * MYSEKAI_HARVEST_MAP_IMAGE_SCALE)
        half_size = spawn_size // 2
        draw.line([(center_x - half_size, center_y - half_size), (center_x + half_size, center_y + half_size)], fill=RED, width=3)
        draw.line([(center_x + half_size, center_y - half_size), (center_x - half_size, center_y + half_size)], fill=RED, width=3)

    if hasattr(data, 'dropped_resources'):
        for res in data.dropped_resources:
            if res.light_size:
                try:
                    light_img = loader.get("mysekai/light.png").resize((res.light_size, res.light_size), Image.Resampling.LANCZOS)
                    pos_x = int(res.x + res.size / 2 - res.light_size / 2)
                    pos_y = int(res.z + res.size / 2 - res.light_size / 2)
                    canvas.paste(light_img, (pos_x, pos_y), light_img)
                except Exception: pass
        for res in data.dropped_resources:
            if res.image.width <= 1: continue
            img_resized = res.image.resize((res.size, res.size), Image.Resampling.LANCZOS)
            canvas.paste(img_resized, (res.x, res.z), img_resized)
            if res.outline:
                draw.rectangle([(res.x, res.z), (res.x + res.size, res.z + res.size)], outline=res.outline[0], width=res.outline[1])
        for res in data.dropped_resources:
            if res.is_small_icon: continue
            text = f"{res.quantity}"
            pos = (res.x, res.z - 1)
            scale = MYSEKAI_HARVEST_MAP_IMAGE_SCALE
            font_size = int(11 * scale); font_path = DEFAULT_BOLD_FONT_PATH; color = (50, 50, 50, 255)
            if res.quantity == 2: font_path, font_size, color = DEFAULT_HEAVY_FONT_PATH, int(13 * scale), (200, 20, 0, 255)
            elif res.quantity > 2: font_path, font_size, color = DEFAULT_HEAVY_FONT_PATH, int(13 * scale), (200, 20, 200, 255)
            font = ImageFont.truetype(font_path, font_size)
            draw.text(pos, text, font=font, fill=color)

    return canvas

# ======================================================================
#  图片拼接逻辑 (保持不变)
# ======================================================================
def combine_and_save_maps(map_data_list: List[HarvestMapDrawData], loader, filename: str):
    map_images = [draw_harvest_map_image(data, loader) for data in map_data_list]
    map_images = [img for img in map_images if img and img.width > 1]
    if not map_images:
        print("Warning: No valid maps were generated to combine.")
        return

    base_name, extension = os.path.splitext(filename)
    print("Saving individual maps...")
    for i, img in enumerate(map_images):
        site_id = map_data_list[i].site_id
        map_name = SITE_ID_TO_NAME_MAP.get(site_id, f"unknown_{site_id}")
        individual_filename = f"{base_name}_map_{map_name}{extension}"
        try:
            img.save(individual_filename)
            print(f"  - Saved: {individual_filename}")
        except Exception as e:
            print(f"  - FAILED to save {individual_filename}: {e}")

    cols = 2; rows = math.ceil(len(map_images) / cols); gap = 16
    col_widths = [0] * cols; row_heights = [0] * rows
    for i, img in enumerate(map_images):
        row, col = i // cols, i % cols
        if img.width > col_widths[col]: col_widths[col] = img.width
        if img.height > row_heights[row]: row_heights[row] = img.height

    total_w = sum(col_widths) + gap * (cols - 1) + BG_PADDING * 2
    total_h = sum(row_heights) + gap * (rows - 1) + BG_PADDING * 2
    final_canvas = Image.new("RGBA", (total_w, total_h), (200, 220, 255, 255))

    current_y = BG_PADDING
    for r in range(rows):
        current_x = BG_PADDING
        for c in range(cols):
            i = r * cols + c
            if i < len(map_images):
                final_canvas.paste(map_images[i], (current_x, current_y))
            current_x += col_widths[c] + gap
        current_y += row_heights[r] + gap

    final_image = add_watermark(final_canvas, text=DEFAULT_WATERMARK)
    final_image.save(filename)
    print(f"Combined map saved as: {filename}")